/********************************************************************************************
 *     LEGAL DISCLAIMER
 *
 *     (Header of MediaTek Software/Firmware Release or Documentation)
 *
 *     BY OPENING OR USING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
 *     THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE") RECEIVED
 *     FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON AN "AS-IS" BASIS
 *     ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES, EXPRESS OR IMPLIED,
 *     INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR
 *     A PARTICULAR PURPOSE OR NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY
 *     WHATSOEVER WITH RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
 *     INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK
 *     ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
 *     NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S SPECIFICATION
 *     OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
 *
 *     BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE LIABILITY WITH
 *     RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION,
TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE
 *     FEES OR SERVICE CHARGE PAID BY BUYER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
 *
 *     THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE WITH THE LAWS
 *     OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF LAWS PRINCIPLES.
 ************************************************************************************************/

#ifndef _AAA_HAL_BASE_H_
#define _AAA_HAL_BASE_H_

#include "aaa_param.h"

/*******************************************************************************
*
********************************************************************************/
//#define HAL_3A_SCENE_MODE          0x0001
#define HAL_3A_AE_MODE                                      0x1001
#define HAL_3A_AE_EVCOMP                                  0x1002
#define HAL_3A_AE_METERING_MODE                   0x1003
#define HAL_3A_AE_ISOSPEED                               0x1004
#define HAL_3A_AE_STROBE_MODE                        0x1005
#define HAL_3A_AE_REDEYE_MODE                        0x1006
#define HAL_3A_AE_FLICKER_MODE                       0x1007
#define HAL_3A_AE_FRAMERATE_MODE                 0x1008
#define HAL_3A_AE_FPS_MIN_MAX                         0x1009
#define HAL_3A_AE_SUPPORT_FPS_NUM                 0x100A
#define HAL_3A_AE_SUPPORT_FPS_RANGE             0x100B
#define HAL_3A_AE_FLICKER_AUTO_MODE             0x100D
#define HAL_3A_AE_PREVIEW_MODE                       0x100E

#define HAL_3A_AF_MODE             0x2000
#define HAL_3A_AF_METERING_MODE    0x2001
#define HAL_3A_AF_METERING_POS     0x2002

#define HAL_3A_AWB_MODE            0x3000

/*******************************************************************************
*
********************************************************************************/
#define HAL_3A_UPDATE_ISO (0x1)
#define HAL_3A_UPDATE_CCT (0x2)
#define HAL_3A_UPDATE_ASD_INFO (0x4)

/*******************************************************************************
*
********************************************************************************/
typedef enum Hal3ASensorType_s {
    HAL3A_SENSOR_TYPE_RAW = 0,
    HAL3A_SENSOR_TYPE_YUV = 1,
    HAL3A_SENSOR_TYPE_RGB565 = 2,
    HAL3A_SENSOR_TYPE_UNKNOWN = 0xFF,
} Hal3ASensorType_e;

typedef enum
{
    HAL3A_SENSOR_DEV_NONE = 0x0,
    HAL3A_SENSOR_DEV_MAIN = 0x1,
    HAL3A_SENSOR_DEV_SUB  = 0x2,
    HAL3A_SENSOR_DEV_ATV  = 0x4,
}Hal3ASensorDev_e;

typedef struct mhalCamMoveSpotInfo_s {
    UINT32 u4OffsetX;
    UINT32 u4OffsetY;
    UINT32 u4DispX;
    UINT32 u4DispY;
    UINT32 u4DispW;
    UINT32 u4DispH;
    UINT32 u4Rotate;
} mhalCamMoveSpotInfo_t;

typedef enum Hal3A_AFLampMode_s {
    HAL3A_AF_LAMP_MODE_OFF = 0,
    HAL3A_AF_LAMP_MODE_ON = 1,
    HAL3A_AF_LAMP_MODE_AUTO = 2,    
} Hal3A_AFLampMode_e;

typedef struct Hal3A_HDROutputParam_S
{
    MUINT32 u4OutputFrameNum;     // Output frame number (2 or 3)
    MUINT32 u4FinalGainDiff[2];   // 1x=1024; [0]: Between short exposure and 0EV; [1]: Between 0EV and long exposure
    MUINT32 u4TargetTone; //Decide the curve to decide target tone     
} Hal3A_HDROutputParam_T;


/*******************************************************************************
*
********************************************************************************/
class Hal3ABase {
public:
    //
    static Hal3ABase* createInstance(Hal3ASensorType_e a_eSensorType, MINT32 sensorDev);
    virtual void      destroyInstance() = 0;
    virtual ~Hal3ABase() {};

    /////////////////////////////////////////////////////////////////////////
    //
    // init () -
    //! \brief init 3A hal
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 init(MINT32 a_i4SensorType) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // uninit () -
    //! \brief uninit 3A hal
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 uninit() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // setState () -
    //! \brief set 3A state
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 setState(MINT32 a_i4aaaState) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // do3A () -
    //! \brief 3A process
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 do3A(MINT32 a_i4aaaState, MUINT32 *a_pWaitVDNum) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // setPreviewParam () -
    //! \brief set preview 3A parameter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 setPreviewParam() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // setCaptureParam () -
    //! \brief set capture 3A paramter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 setCaptureParam(MUINT32 a_IsRawInDram) {return 0;}
    
    /////////////////////////////////////////////////////////////////////////
    //
    // setCaptureHDRParam () -
    //! \brief set capture HDR 3A paramter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 setCaptureHDRParam( MUINT32 a_u4CntIdx, MINT32 a_IsRawGain) {return 0;}
    
    /////////////////////////////////////////////////////////////////////////
    //
    // set3AParam () -
    //! \brief set 3A parameter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 set3AParam(MINT32 a_i4Param0, MINT32 a_i4Param1, MINT32 a_i4Param2, MINT32 a_i4Param3) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // get3AParam () -
    //! \brief get 3A parameter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 get3AParam(MINT32 a_i4Param0, MINT32 *a_pParam1) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // enableAE () -
    //! \brief enable AE function
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 enableAE() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // disableAE () -
    //! \brief disable AE function
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 disableAE() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // enableAWB () -
    //! \brief enable AWB Function
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 enableAWB() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // disableAWB () -
    //! \brief disable AWB function
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 disableAWB() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // enableAF () -
    //! \brief enable AF function
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 enableAF() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // disableAF () -
    //! \brief disable AF function
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 disableAF() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // getAFDone () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 getAFDone() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // getAFValueAll () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MVOID getAFValueAll(AF_STAT_T &a_rAFStat) {return;}

    /////////////////////////////////////////////////////////////////////////
    //
    // getAFBestPos () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 getAFBestPos() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // isAFFinish () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 isAFFinish() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // pauseFocus () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual void   pauseFocus() {return;}

    /////////////////////////////////////////////////////////////////////////
    //
    // isFocused () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MBOOL   isFocused() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // resetFocus () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////	
	virtual void    resetFocus() {return;}

    /////////////////////////////////////////////////////////////////////////
    //
    // setFocusAreas () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////	
	virtual void    setFocusAreas(MINT32 a_i4Cnt, AREA_T *a_psFocusArea) {return;}

    /////////////////////////////////////////////////////////////////////////
    //
    // getFocusAreas () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////	
	virtual void    getFocusAreas(MINT32 &a_i4Cnt, AREA_T **a_psFocusArea) {return;}

    /////////////////////////////////////////////////////////////////////////
    //
    // getMaxNumFocusAreas () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32  getMaxNumFocusAreas() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // lockHalfPushAEAWB () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 lockHalfPushAEAWB(MBOOL a_bLockAEAWB) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // setEZoomInfo () -
    //! \brief set zoom info
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 setEZoomInfo(MUINT32 a_u4XOffset, MUINT32 a_u4YOffset, MUINT32 a_u4Width, MUINT32 a_u4Height) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // setFDInfo () -
    //! \brief set FD Info
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 setFDInfo(MUINT32 a_u4IsFDOn, MUINT32 a_u4Addr) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // drawFocusRect () -
    //! \brief to get the best shot value
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 drawFocusRect(MUINT8 *a_pBuf, MUINT32 a_u4DispW, MUINT32 a_u4DispH, MUINT32 a_u4DispX, MUINT32 a_u4DispY, MUINT32 a_u4Rotate) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // getDebugInfo () -
    //! \brief get 3A debug info
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 getDebugInfo(MVOID **a_p3ADebugInfo, MUINT32 *a_u4SizeInByte) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // eableBestShot () -
    //! \brief enable best shot
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MVOID enableBestShot() {}

    /////////////////////////////////////////////////////////////////////////
    //
    // disableBestShot () -
    //! \brief disable best shot
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MVOID disableBestShot() {}

    /////////////////////////////////////////////////////////////////////////
    //
    // bestShotProcess () -
    //! \brief process best shot
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MVOID bestShotProcess() {}

    /////////////////////////////////////////////////////////////////////////
    //
    // getBestShotValue () -
    //! \brief to get the best shot value
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MUINT32 getBestShotValue() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // enableAFLamp () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MVOID enableAFLamp() {}

    /////////////////////////////////////////////////////////////////////////
    //
    // autoAFLamp () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MVOID autoAFLamp() {}

    /////////////////////////////////////////////////////////////////////////
    //
    // disableAFLamp () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MVOID disableAFLamp() {}

    /////////////////////////////////////////////////////////////////////////
    //
    // getReadyForCapture () -
    //! \brief check if 3A is done and ready for capture
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 getReadyForCapture() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // get3AEXIFInfo () -
    //! \brief get exif info
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 get3AEXIFInfo(MVOID *a_p3AEXIFInfo) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // resetHalfPushState () -
    //! \brief reset half button push state
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 resetHalfPushState() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // getAFWinResult () -
    //! \brief get AF window result
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 getAFWinResult(MINT32 *a_pBuf, MINT32 *a_pWinW, MINT32 *a_pWinH) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // setAFFullStep () -
    //! \brief to
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 setAFFullStep(MINT32 a_i4Step) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // setMFPos () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 setMFPos(MINT32 a_i4MFPos) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // setFocusDistanceRange () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setFocusDistanceRange(MINT32 a_i4Distance_N, MINT32 a_i4Distance_M) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // getFocusDistance () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 getFocusDistance(MINT32 &a_i4Near, MINT32 &a_i4Curr, MINT32 &a_i4Far) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // getISO () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 getISO(MINT32 a_i4Mode, MINT32 *a_pISO) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // getCCT () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 getCCT(MINT32 a_i4Mode, MVOID *a_pCCT) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // getLV () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 getLV(MINT32 *a_pLV) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // getAEHDRCaptureMode () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 getAEHDRCaptureMode(AE_HDR_INFO_T *pAEHDRInfo) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // getAEPlineEV () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 getAEPlineEV(MINT32 *a_pLV) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAEEnable () -
    //! \brief CCTOP: enable AE
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAEEnable() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAEDisable () -
    //! \brief CCTOP: disable AE
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAEDisable() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAEGetEnableInfo () -
    //! \brief CCTOP: get AE enable info
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAEGetEnableInfo(MINT32 *a_pEnableAE,
                                        MUINT32 *a_pOutLen) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAESetAEMode () -
    //! \brief CCTOP: set AE mode
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAESetAEMode(MINT32 a_AEMode) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAEGetNVRAMParam () -
    //! \brief CCTOP: get AE NVRAM parameter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAEGetNVRAMParam(MVOID *a_pAENVRAM,
                                        MUINT32 *a_pOutLen) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAEGetAEMode () -
    //! \brief CCTOP: get AE mode
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAEGetAEMode(MINT32 *a_pAEMode,
                                    MUINT32 *a_pOutLen) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAESetMeteringMode () -
    //! \brief CCTOP: set AE metering mode
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAESetMeteringMode(MINT32 a_AEMeteringMode)  {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAEApplyExpParam () -
    //! \brief CCTOP: apply AE exposure parameter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAEApplyExpParam(MVOID *a_pAEExpParam) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAESetFlickerMode () -
    //! \brief CCTOP: set AE flicker mode
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAESetFlickerMode(MINT32 a_AEFlickerMode) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAEGetExpParam () -
    //! \brief CCTOP: get AE exposure parameter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAEGetExpParam(MVOID *a_pAEExpParamIn,
                                      MVOID *a_pAEExpParamOut,
                                      MUINT32 *a_pOutLen ) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAEGetFlickerMode () -
    //! \brief CCTOP: get AE flicker mode
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAEGetFlickerMode(MINT32 *a_pAEFlickerMode,
                                         MUINT32 *a_pOutLen) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAEGetMeteringMode () -
    //! \brief CCTOP: get AE metering mode
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAEGetMeteringMode(MINT32 *a_pAEMEteringMode,
                                          MUINT32 *a_pOutLen) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAEApplyNVRAMParam () -
    //! \brief CCTOP: apply AE NVRAM parameter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAEApplyNVRAMParam(MVOID *a_pAENVRAM) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAESaveNVRAMParam () -
    //! \brief CCTOP: save AE NVRAM parameter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAESaveNVRAMParam() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAEGetCurrentEV () -
    //! \brief CCTOP: get AE current EV
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAEGetCurrentEV(MINT32 *a_pAECurrentEV,
                                       MUINT32 *a_pOutLen) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAELockExpSetting () -
    //! \brief CCTOP: lock AE exposure setting
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAELockExpSetting() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAEUnLockExpSetting () -
    //! \brief CCTOP: unlock AE exposure setting
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAEUnLockExpSetting() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAEGetIspOB () -
    //! \brief get ISP OB
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAEGetIspOB(MUINT32 *a_pIspOB,
                                   MUINT32 *a_pOutLen) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAESetIspOB () -
    //! \brief set ISP OB
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAESetIspOB(MUINT32 a_IspOB) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAEGetIspRAWGain () -
    //! \brief get ISP RAW gain
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAEGetIspRAWGain(MUINT32 *a_pIspRawGain,
                                        MUINT32 *a_pOutLen) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAESetIspRAWGain () -
    //! \brief set ISP RAW gain
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAESetIspRAWGain(MUINT32 a_IspRAWGain) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAESetSensorExpTime () -
    //! \brief set sensor exosure time
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAESetSensorExpTime(MUINT32 a_ExpTime)  {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAESetSensorExpLine () -
    //! \brief set sensor exosure line
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAESetSensorExpLine(MUINT32 a_ExpLine) const{return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAESetSensorGain () -
    //! \brief set sensor gain
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAESetSensorGain(MUINT32 a_SensorGain) const {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAESetCaptureMode () -
    //! \brief set capture gain
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAESetCaptureMode(MUINT32 a_CaptureMod) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAWBEnable () -
    //! \brief CCTOP: enable AWB
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAWBEnable() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAWBDisable () -
    //! \brief CCTOP: disable AWB
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAWBDisable() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAWBGetEnableInfo () -
    //! \brief CCTOP: get AWB enable info
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAWBGetEnableInfo(MINT32 *a_pEnableAWB,
                                         MUINT32 *a_pOutLen) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAWBGetAWBGain () -
    //! \brief CCTOP: get the AWB gain
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAWBGetAWBGain(MVOID *a_pAWBGain,
                                      MUINT32 *a_pOutLen) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAWBSetAWBGain () -
    //! \brief CCTOP: set the AWB gain
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAWBSetAWBGain(MVOID *a_pAWBGain) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAWBApplyNVRAMParam () -
    //! \brief CCTOP: apply AWB NVRAM parameter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAWBApplyNVRAMParam(MVOID *a_pAWBNVRAM) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAWBGetNVRAMParam () -
    //! \brief CCTOP: get AWB NVRAM parameter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAWBGetNVRAMParam(MVOID *a_pAWBNVRAM,
                                         MUINT32 *a_pOutLen) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAWBSaveNVRAMParam () -
    //! \brief CCTOP: save AWB NVRAM parameter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAWBSaveNVRAMParam() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAWBSetAWBMode () -
    //! \brief CCTOP: set AWB mode
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAWBSetAWBMode(MINT32 a_AWBMode )  {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAWBGetAWBMode () -
    //! \brief CCTOP: get AWB mode
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAWBGetAWBMode(MINT32 *a_pAWBMode,
                                      MUINT32 *a_pOutLen) {return 0;}


    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAWBGetLightProb () -
    //! \brief CCTOP: get AWB light probability
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAWBGetLightProb(MVOID *a_pAWBLightProb,
                                        MUINT32 *a_pOutLen) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAFOpeartion () -
    //! \brief CCTOP: AF operation
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAFOpeartion() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPMFOpeartion () -
    //! \brief CCTOP: MF operation
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPMFOpeartion(MINT32 a_MFpos) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAFGetAFInfo () -
    //! \brief CCTOP: get AF info
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAFGetAFInfo(MVOID *a_pAFInfo,
                                    MUINT32 *a_pOutLen) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAFGetBestPos () -
    //! \brief CCTOP: get AF best position
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAFGetBestPos(INT32 *a_pAFBestPos,
                                     MUINT32 *a_pOutLen) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAFCaliOperation () -
    //! \brief CCTOP: AF calibration operation
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAFCaliOperation(MVOID *a_pAFCaliData,
                                        MUINT32 *a_pOutLen ) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAFSetFocusRange () -
    //! \brief CCTOP: set focus range
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAFSetFocusRange(MVOID *a_pFocusRange) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAFGetFocusRange () -
    //! \brief CCTOP: get focus range
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAFGetFocusRange(MVOID *a_pFocusRange,
                                        MUINT32 *a_pOutLen) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAFGetNVRAMParam () -
    //! \brief CCTOP: get AF NVRAM parameter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAFGetNVRAMParam(MVOID *a_pAFNVRAM,
                                        MUINT32 *a_pOutLen) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAFApplyNVRAMParam () -
    //! \brief CCTOP: apply AF NVRAM parameter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAFApplyNVRAMParam(MVOID *a_pAFNVRAM) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAFSaveNVRAMParam () -
    //! \brief CCTOP: save AF NVRAM parameter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAFSaveNVRAMParam() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAFGetFV () -
    //! \brief CCTOP: get focus value
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAFGetFV(MVOID *a_pAFPosIn,
                                MVOID *a_pAFValueOut,
                                MUINT32 *a_pOutLen) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAFEnable () -
    //! \brief CCTOP: enable AF
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAFEnable() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAFDisable () -
    //! \brief CCTOP: disable AF
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAFDisable() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAFGetEnableInfo () -
    //! \brief CCTOP: get AF enable info
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAFGetEnableInfo(MVOID *a_pEnableAF,
                                        MUINT32 *a_pOutLen) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // Author : Cotta
    // Functionality :
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPFlashEnable() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // Author : Cotta
    // Functionality : 
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPFlashDisable() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPFlashGetEnableInfo () -
    //! \brief CCTOP: get flash enable info
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPFlashGetEnableInfo(MINT32 *a_pEnableFlash,
                                           MUINT32 *a_pOutLen) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPFlashControl () -
    //! \brief CCTOP: flash control
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPFlashControl(MVOID *a_pflashCtrl) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // Author : Cotta
    // Functionality : strobe high current - low current ratio tuning
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPStrobeRatioTuning(MUINT32 level, MUINT32 *dataArray) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // getASDInfo () -
    //! \brief get ASD info
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 getASDInfo(AAA_ASD_INFO_T &a_ASDInfo) {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // getHDRCapInfo () -
    //! \brief get HDR Cap info
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 getHDRCapInfo(Hal3A_HDROutputParam_T & strHDROutputInfo) {return 0;}

    virtual void setFlashActive(MBOOL a_FlashActive){return;}
    virtual MBOOL getFlashActive(void){return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // setAutoExposureLock() -
    //! \brief enable/disable AE function
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MVOID setAutoExposureLock(MBOOL bEnable) {return;}

    /////////////////////////////////////////////////////////////////////////
    //
    // getAutoExposureLock() -
    //! \brief get AE lock state
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MBOOL getAutoExposureLock() {return 0;}
    
    /////////////////////////////////////////////////////////////////////////
    //
    // isAutoExposureLockSupported() -
    //! \brief AE support lock or not
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MBOOL isAutoExposureLockSupported() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // getMaxNumMeteringAreas() -
    //! \brief get AE support max number of metering area
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 getMaxNumMeteringAreas() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // getMeteringAreas() -
    //! \brief get AE metering area information
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MVOID getMeteringAreas(MINT32 &a_i4Cnt, AREA_T **a_psAEArea) {return;}

    /////////////////////////////////////////////////////////////////////////
    //
    // setMeteringAreas() -
    //! \brief set AE metering area information
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MVOID setMeteringAreas(MINT32 a_i4Cnt, AREA_T const *a_psAEArea) {return;}

    /////////////////////////////////////////////////////////////////////////
    //
    // isStrobeOn() -
    //! \brief strobe on or not
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MBOOL isStrobeOn() {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // isAutoWhiteBalanceLockSupported () -
    //! \brief [ICS] returns true if auto-white balance locking is supported
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MBOOL isAutoWhiteBalanceLockSupported()  {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // getAutoWhiteBalanceLock () -
    //! \brief [ICS] Gets the state of the auto-white balance lock: Returns true if auto-white balance is currently locked, and false otherwise
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MBOOL getAutoWhiteBalanceLock()  {return 0;}

    /////////////////////////////////////////////////////////////////////////
    //
    // setAutoWhiteBalanceLock () -
    //! \brief [ICS] If set to true, the camera auto-white balance routine will immediately pause until the lock is set to false.
    //               If auto-white balance is already locked, setting this to true again has no effect (the driver will not recalculate white balance values).
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MVOID setAutoWhiteBalanceLock(MBOOL bToggle)  {return;}

    /////////////////////////////////////////////////////////////////////////
    //
    // Author : Cotta
    // Functionality : main-flash delay function, used for strobe protection
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MVOID strobeDelay() {} 

    /////////////////////////////////////////////////////////////////////////
    //
    // Author : Cotta
    // Functionality : set ZSD mode strobe on / off
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MVOID set3AZSDMode(MBOOL ZSDFlag) {}

    /*******************************************************************************
    // setPreviewToCaptureImage () -
    //! \brief [ICS] If set to zero, the camera will use the preview setting to capture image.
    ********************************************************************************/
    virtual MVOID setPreviewToCaptureImage(MUINT32 a_CaptureMode) {}

    /*******************************************************************************
    // setBypassSensorSetting () -
    //! \brief If the flag is TRUE, the capture function will not update the sensor and gain parameters.
    ********************************************************************************/
    virtual MVOID setBypassSensorSetting(MBOOL bBypassSensorSetting) {}

    virtual MVOID setZSDMode(MBOOL ZSDFlag) = 0;

    virtual MVOID FocusThread(MINT32 enable) = 0;
    
    virtual MVOID setIsBurtShootMode(MINT32 isBurst) = 0;
    /////////////////////////////////////////////////////////////////////////
    //   setHal3AMeteringModeStatus() -
    //! \brief set 3A metering mode to let AE understand the current mode.
    //! \param [in] a_i4MeteringModeStatus 0 : video preview, 1:video recording, 2:camera preview
    //! \return 0 if success, 1 if failed.
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MRESULT setHal3AMeteringModeStatus(MINT32 a_i4MeteringModeStatus) {return 0;} 
	virtual MVOID setStrobeOn(MBOOL bEnable){return;}

protected:


private:

};

#endif

