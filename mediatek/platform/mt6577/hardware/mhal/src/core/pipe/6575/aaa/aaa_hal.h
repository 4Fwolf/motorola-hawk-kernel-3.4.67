/********************************************************************************************
 *     LEGAL DISCLAIMER
 *
 *     (Header of MediaTek Software/Firmware Release or Documentation)
 *
 *     BY OPENING OR USING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
 *     THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE") RECEIVED
 *     FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON AN "AS-IS" BASIS
 *     ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES, EXPRESS OR IMPLIED,
 *     INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR
 *     A PARTICULAR PURPOSE OR NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY
 *     WHATSOEVER WITH RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
 *     INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK
 *     ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
 *     NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S SPECIFICATION
 *     OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
 *
 *     BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE LIABILITY WITH
 *     RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION,
TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE
 *     FEES OR SERVICE CHARGE PAID BY BUYER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
 *
 *     THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE WITH THE LAWS
 *     OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF LAWS PRINCIPLES.
 ************************************************************************************************/

#ifndef _AAA_HAL_H_
#define _AAA_HAL_H_

#include <utils/threads.h>
#include <sys/time.h>
#include <cutils/xlog.h>
#include "aaa_hal_base.h"
#include "kd_camera_feature.h"
#include "isp_reg.h"

class NvramDrvBase;
class IspDrv;
class MCUDrv;
class StrobeDrv;
class SensorDrv;
class MTK3A;


/*******************************************************************************
*
********************************************************************************/
#define HAL_3A_AE_WIN_RESULT_NUM (20)
#define HAL_3A_INFO_NUM (4)
#define HAL_3A_FLARE_HISTOGRAM_BIN_NUM (10)
#define HAL_3A_AF_WIN_NUM (9)
#define HAL_3A_AF_THRESHOLD_NUM (5)
#define HAL_3A_AWB_WIN_NUM (12)
#define HAL_3A_HISTOGRAM_BIN_NUM (64)
#define HAL_3A_FD_AE_WIN_NUM (4)

/*******************************************************************************
*
********************************************************************************/
class Hal3A : public Hal3ABase
{
public:
    static Hal3ABase* getInstance();

    /////////////////////////////////////////////////////////////////////////
    //
    // Author : Cotta
    // Functionality : ISP callback function to turn on strobe. sync with ISP start
    //
    /////////////////////////////////////////////////////////////////////////
    void strobeOnISPCallback();

    /////////////////////////////////////////////////////////////////////////
    //
    // Author : Cotta
    // Functionality : ISP callback function to turn off strobe. sync with ISP stop
    //
    /////////////////////////////////////////////////////////////////////////
    void strobeOffISPCallback();

private:
    Hal3A();
    virtual ~Hal3A();

    
    static void* AFThreadFunc(void *arg);

public:
    virtual void destroyInstance();

public:
    
    virtual void FocusThread(MINT32 enable);
        
    /////////////////////////////////////////////////////////////////////////
    //
    // init () -
    //! \brief init 3A hal
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 init(MINT32 a_i4SensorType);

    /////////////////////////////////////////////////////////////////////////
    //
    // uninit () -
    //! \brief uninit 3A hal
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 uninit();

    /////////////////////////////////////////////////////////////////////////
    //
    // setState () -
    //! \brief set 3A state
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 setState(MINT32 a_i4aaaState);

    /////////////////////////////////////////////////////////////////////////
    //
    // do3A () -
    //! \brief 3A process
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 do3A(MINT32 a_i4aaaState, MUINT32 *a_pWaitVDNum);

    /////////////////////////////////////////////////////////////////////////
    //
    // setPreviewParam () -
    //! \brief set preview 3A parameter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 setPreviewParam();

    /////////////////////////////////////////////////////////////////////////
    //
    // setCaptureParam () -
    //! \brief set capture 3A paramter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 setCaptureParam(MUINT32 a_u4IsRawInDram);

    /////////////////////////////////////////////////////////////////////////
    //
    // setCaptureHDRParam () -
    //! \brief set capture 3A paramter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 setCaptureHDRParam( MUINT32 a_u4CntIdx, MINT32 a_IsRawGain);

    /////////////////////////////////////////////////////////////////////////
    //
    // set3AParam () -
    //! \brief set 3A parameter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 set3AParam(MINT32 a_i4Param0, MINT32 a_i4aram1, MINT32 a_i4aram2, MINT32 a_i4aram3);

    /////////////////////////////////////////////////////////////////////////
    //
    // get3AParam () -
    //! \brief get 3A parameter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 get3AParam(MINT32 a_i4Param0, MINT32 *a_pParam1);

    /////////////////////////////////////////////////////////////////////////
    //
    // enableAE () -
    //! \brief enable AE function
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 enableAE();

    /////////////////////////////////////////////////////////////////////////
    //
    // disableAE () -
    //! \brief disable AE function
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 disableAE();

    /////////////////////////////////////////////////////////////////////////
    //
    // enableAWB () -
    //! \brief enable AWB Function
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 enableAWB();

    /////////////////////////////////////////////////////////////////////////
    //
    // disableAWB () -
    //! \brief disable AWB function
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 disableAWB();

    /////////////////////////////////////////////////////////////////////////
    //
    // enableAF () -
    //! \brief enable AF function
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 enableAF();

    /////////////////////////////////////////////////////////////////////////
    //
    // disableAF () -
    //! \brief disable AF function
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 disableAF();

    /////////////////////////////////////////////////////////////////////////
    //
    // getAFDone () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 getAFDone();

    /////////////////////////////////////////////////////////////////////////
    //
    // getAFBestPos () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 getAFBestPos();

    /////////////////////////////////////////////////////////////////////////
    //
    // isAFFinish () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 isAFFinish();

    /////////////////////////////////////////////////////////////////////////
    //
    // doAF () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual void   doAF();

    /////////////////////////////////////////////////////////////////////////
    //
    // setDoFocusState () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual void   setDoFocusState();

    /////////////////////////////////////////////////////////////////////////
    //
    // pauseFocus () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual void   pauseFocus();

    /////////////////////////////////////////////////////////////////////////
    //
    // isFocused () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MBOOL   isFocused();

    /////////////////////////////////////////////////////////////////////////
    //
    // resetFocus () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////	
	virtual void    resetFocus();

    /////////////////////////////////////////////////////////////////////////
    //
    // setFocusAreas () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////	
	virtual void    setFocusAreas(MINT32 a_i4Cnt, AREA_T *a_psFocusArea);

    /////////////////////////////////////////////////////////////////////////
    //
    // getFocusAreas () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////	
	virtual void    getFocusAreas(MINT32 &a_i4Cnt, AREA_T **a_psFocusArea);

    /////////////////////////////////////////////////////////////////////////
    //
    // getMaxNumFocusAreas () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32  getMaxNumFocusAreas();

    /////////////////////////////////////////////////////////////////////////
    //
    // lockHalfPushAEAWB () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 lockHalfPushAEAWB(MBOOL a_bLockAEAWB);

    /////////////////////////////////////////////////////////////////////////
    //
    // setEZoomInfo () -
    //! \brief set zoom info
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 setEZoomInfo(MUINT32 a_u4XOffset, MUINT32 a_u4YOffset, MUINT32 a_u4Width, MUINT32 a_u4Height);

    /////////////////////////////////////////////////////////////////////////
    //
    // setFDInfo () -
    //! \brief set FD Info
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 setFDInfo(MUINT32 a_u4IsFDOn, MUINT32 a_u4Addr);

    /////////////////////////////////////////////////////////////////////////
    //
    // drawFocusRect () -
    //! \brief to get the best shot value
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 drawFocusRect(MUINT8 *a_pBuf, MUINT32 a_u4DispW, MUINT32 a_u4DispH, MUINT32 a_u4DispX, MUINT32 a_u4DispY, MUINT32 a_u4Rotate);

    /////////////////////////////////////////////////////////////////////////
    //
    // getDebugInfo () -
    //! \brief get 3A debug info
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 getDebugInfo(MVOID **a_p3ADebugInfo, MUINT32 *a_u4SizeInByte);

    /////////////////////////////////////////////////////////////////////////
    //
    // eableBestShot () -
    //! \brief enable best shot
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MVOID enableBestShot();

    /////////////////////////////////////////////////////////////////////////
    //
    // disableBestShot () -
    //! \brief disable best shot
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MVOID disableBestShot();

    /////////////////////////////////////////////////////////////////////////
    //
    // bestShotProcess () -
    //! \brief process best shot
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MVOID bestShotProcess() ;

    /////////////////////////////////////////////////////////////////////////
    //
    // getBestShotValue () -
    //! \brief to get the best shot value
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MUINT32 getBestShotValue();

    /////////////////////////////////////////////////////////////////////////
    //
    // enableAFLamp () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MVOID enableAFLamp();

    /////////////////////////////////////////////////////////////////////////
    //
    // autoAFLamp () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MVOID autoAFLamp();

    /////////////////////////////////////////////////////////////////////////
    //
    // disableAFLamp () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MVOID disableAFLamp();

    /////////////////////////////////////////////////////////////////////////
    //
    // getReadyForCapture () -
    //! \brief check if 3A is done and ready for capture
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 getReadyForCapture();

    /////////////////////////////////////////////////////////////////////////
    //
    // get3AEXIFInfo () -
    //! \brief get exif info
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 get3AEXIFInfo(MVOID *a_p3AEXIFInfo);

    /////////////////////////////////////////////////////////////////////////
    //
    // resetHalfPushState () -
    //! \brief reset half button push state
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 resetHalfPushState() ;

    /////////////////////////////////////////////////////////////////////////
    //
    // getAFWinResult () -
    //! \brief get AF window result
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 getAFWinResult(MINT32 *a_pBuf, MINT32 *a_pWinW, MINT32 *a_pWinH);

    /////////////////////////////////////////////////////////////////////////
    //
    // setAFFullStep () -
    //! \brief to
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 setAFFullStep(MINT32 a_i4Step);

    /////////////////////////////////////////////////////////////////////////
    //
    // setMFPos () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 setMFPos(MINT32 a_i4MFPos);

    /////////////////////////////////////////////////////////////////////////
    //
    // setFocusDistanceRange () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setFocusDistanceRange(MINT32 a_i4Distance_N, MINT32 a_i4Distance_M);

    /////////////////////////////////////////////////////////////////////////
    //
    // getFocusDistance () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 getFocusDistance(MINT32 &a_i4Near, MINT32 &a_i4Curr, MINT32 &a_i4Far);

    /////////////////////////////////////////////////////////////////////////
    //
    // getISO () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 getISO(MINT32 a_i4Mode, MINT32 *a_pISO);

    /////////////////////////////////////////////////////////////////////////
    //
    // getCCT () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 getCCT(MINT32 a_i4Mode, MVOID *a_pCCT);

    /////////////////////////////////////////////////////////////////////////
    //
    // getLV () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 getLV(MINT32 *a_pLV);

    /////////////////////////////////////////////////////////////////////////
    //
    // getAEPlineEV () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 getAEPlineEV(MINT32 *a_pLV);

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAEEnable () -
    //! \brief CCTOP: enable AE
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAEEnable();

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAEDisable () -
    //! \brief CCTOP: disable AE
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAEDisable();

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAEGetEnableInfo () -
    //! \brief CCTOP: get AE enable info
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAEGetEnableInfo(MINT32 *a_pEnableAE,
                                        MUINT32 *a_pOutLen);

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAESetAEMode () -
    //! \brief CCTOP: set AE mode
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAESetAEMode(MINT32 a_AEMode) ;

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAEGetNVRAMParam () -
    //! \brief CCTOP: get AE NVRAM parameter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAEGetNVRAMParam(MVOID *a_pAENVRAM,
                                        MUINT32 *a_pOutLen);

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAEGetAEMode () -
    //! \brief CCTOP: get AE mode
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAEGetAEMode(MINT32 *a_pAEMode,
                                    MUINT32 *a_pOutLen);

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAESetMeteringMode () -
    //! \brief CCTOP: set AE metering mode
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAESetMeteringMode(MINT32 a_AEMeteringMode);

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAEApplyExpParam () -
    //! \brief CCTOP: apply AE exposure parameter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAEApplyExpParam(MVOID *a_pAEExpParam);

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAESetFlickerMode () -
    //! \brief CCTOP: set AE flicker mode
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAESetFlickerMode(MINT32 a_AEFlickerMode) ;

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAEGetExpParam () -
    //! \brief CCTOP: get AE exposure parameter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAEGetExpParam(MVOID *a_pAEExpParamIn,
                                      MVOID *a_pAEExpParamOut,
                                      MUINT32 *a_pOutLen );

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAEGetFlickerMode () -
    //! \brief CCTOP: get AE flicker mode
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAEGetFlickerMode(MINT32 *a_pAEFlickerMode,
                                         MUINT32 *a_pOutLen);

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAEGetMeteringMode () -
    //! \brief CCTOP: get AE metering mode
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAEGetMeteringMode(MINT32 *a_pAEMEteringMode,
                                          MUINT32 *a_pOutLen);

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAEApplyNVRAMParam () -
    //! \brief CCTOP: apply AE NVRAM parameter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAEApplyNVRAMParam(MVOID *a_pAENVRAM);

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAESaveNVRAMParam () -
    //! \brief CCTOP: save AE NVRAM parameter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAESaveNVRAMParam();

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAEGetCurrentEV () -
    //! \brief CCTOP: get AE current EV
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAEGetCurrentEV(MINT32 *a_pAECurrentEV,
                                       MUINT32 *a_pOutLen);

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAELockExpSetting () -
    //! \brief CCTOP: lock AE exposure setting
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAELockExpSetting();

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAEUnLockExpSetting () -
    //! \brief CCTOP: unlock AE exposure setting
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAEUnLockExpSetting();

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAEGetIspOB () -
    //! \brief get ISP OB
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAEGetIspOB(MUINT32 *a_pIspOB,
                                   MUINT32 *a_pOutLen);

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAESetIspOB () -
    //! \brief set ISP OB
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAESetIspOB(MUINT32 a_IspOB);

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAEGetIspRAWGain () -
    //! \brief get ISP RAW gain
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAEGetIspRAWGain(MUINT32 *a_pIspRawGain,
                                        MUINT32 *a_pOutLen);

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAESetIspRAWGain () -
    //! \brief set ISP RAW gain
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAESetIspRAWGain(MUINT32 a_IspRAWGain);

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAESetSensorExpTime () -
    //! \brief set sensor exosure time
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAESetSensorExpTime(MUINT32 a_ExpTime) ;

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAESetSensorExpLine () -
    //! \brief set sensor exosure line
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAESetSensorExpLine(MUINT32 a_ExpLine) const;

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAESetSensorGain () -
    //! \brief set sensor gain
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAESetSensorGain(MUINT32 a_SensorGain) const ;

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAESetCaptureMode () -
    //! \brief set capture gain
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAESetCaptureMode(MUINT32 a_CaptureMode)  ;

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAWBEnable () -
    //! \brief CCTOP: enable AWB
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAWBEnable();

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAWBDisable () -
    //! \brief CCTOP: disable AWB
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAWBDisable();

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAWBGetEnableInfo () -
    //! \brief CCTOP: get AWB enable info
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAWBGetEnableInfo(MINT32 *a_pEnableAWB,
                                         MUINT32 *a_pOutLen);

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAWBGetAWBGain () -
    //! \brief CCTOP: get the AWB gain
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAWBGetAWBGain(MVOID *a_pAWBGain,
                                      MUINT32 *a_pOutLen);

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAWBSetAWBGain () -
    //! \brief CCTOP: set the AWB gain
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAWBSetAWBGain(MVOID *a_pAWBGain);

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAWBApplyNVRAMParam () -
    //! \brief CCTOP: apply AWB NVRAM parameter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAWBApplyNVRAMParam(MVOID *a_pAWBNVRAM) ;

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAWBGetNVRAMParam () -
    //! \brief CCTOP: get AWB NVRAM parameter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAWBGetNVRAMParam(void *a_pAWBNVRAM,
                                         MUINT32 *a_pOutLen);

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAWBSaveNVRAMParam () -
    //! \brief CCTOP: save AWB NVRAM parameter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAWBSaveNVRAMParam() ;

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAWBSetAWBMode () -
    //! \brief CCTOP: set AWB mode
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAWBSetAWBMode(MINT32 a_AWBMode )  ;

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAWBGetAWBMode () -
    //! \brief CCTOP: get AWB mode
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAWBGetAWBMode(MINT32 *a_pAWBMode,
                                      MUINT32 *a_pOutLen) ;

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAWBGetLightProb () -
    //! \brief CCTOP: get AWB light probability
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAWBGetLightProb(MVOID *a_pAWBLightProb,
                                        MUINT32 *a_pOutLen);

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAFOpeartion () -
    //! \brief CCTOP: AF operation
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAFOpeartion();

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPMFOpeartion () -
    //! \brief CCTOP: MF operation
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPMFOpeartion(MINT32 a_MFpos) ;

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAFGetAFInfo () -
    //! \brief CCTOP: get AF info
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAFGetAFInfo(MVOID *a_pAFInfo,
                                    MUINT32 *a_pOutLen);

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAFGetBestPos () -
    //! \brief CCTOP: get AF best position
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAFGetBestPos(MINT32 *a_pAFBestPos,
                                     MUINT32 *a_pOutLen) ;

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAFCaliOperation () -
    //! \brief CCTOP: AF calibration operation
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAFCaliOperation(MVOID *a_pAFCaliData,
                                        MUINT32 *a_pOutLen );

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAFSetFocusRange () -
    //! \brief CCTOP: set focus range
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAFSetFocusRange(MVOID *a_pFocusRange);

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAFGetFocusRange () -
    //! \brief CCTOP: get focus range
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAFGetFocusRange(MVOID *a_pFocusRange,
                                        MUINT32 *a_pOutLen) ;

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAFGetNVRAMParam () -
    //! \brief CCTOP: get AF NVRAM parameter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAFGetNVRAMParam(MVOID *a_pAFNVRAM,
                                        MUINT32 *a_pOutLen);

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAFApplyNVRAMParam () -
    //! \brief CCTOP: apply AF NVRAM parameter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAFApplyNVRAMParam(MVOID *a_pAFNVRAM);

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAFSaveNVRAMParam () -
    //! \brief CCTOP: save AF NVRAM parameter
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAFSaveNVRAMParam();

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAFGetFV () -
    //! \brief CCTOP: get focus value
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAFGetFV(MVOID *a_pAFPosIn,
                                MVOID *a_pAFValueOut,
                                MUINT32 *a_pOutLen);

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAFEnable () -
    //! \brief CCTOP: enable AF
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAFEnable();

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAFDisable () -
    //! \brief CCTOP: disable AF
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAFDisable() ;

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPAFGetEnableInfo () -
    //! \brief CCTOP: get AF enable info
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPAFGetEnableInfo(MVOID *a_pEnableAF,
                                        MUINT32 *a_pOutLen) ;

    /////////////////////////////////////////////////////////////////////////
    //
    // Author : Cotta
    // Functionality :
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPFlashEnable();

    /////////////////////////////////////////////////////////////////////////
    //
    // Author : Cotta
    // Functionality : 
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPFlashDisable();

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPFlashGetEnableInfo () -
    //! \brief CCTOP: get flash enable info
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPFlashGetEnableInfo(MINT32 *a_pEnableFlash,
                                           MUINT32 *a_pOutLen);

    /////////////////////////////////////////////////////////////////////////
    //
    // CCTOPFlashControl () -
    //! \brief CCTOP: flash control
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPFlashControl(MVOID *a_pflashCtrl);

    /////////////////////////////////////////////////////////////////////////
    //
    //  Author : Cotta
    // Functionality : strobe high current - low current ratio tuning
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 CCTOPStrobeRatioTuning(MUINT32 level, MUINT32 *dataArray);

    /////////////////////////////////////////////////////////////////////////
    //
    // getASDInfo () -
    //! \brief get ASD info
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 getASDInfo(AAA_ASD_INFO_T &a_ASDInfo);

    /////////////////////////////////////////////////////////////////////////
    //
    // getHDRCapInfo () -
    //! \brief get HDR Cap info
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 getHDRCapInfo(Hal3A_HDROutputParam_T & strHDROutputInfo);

    virtual void setFlashActive(MBOOL a_FlashActive);
    virtual MBOOL getFlashActive(void);

    /////////////////////////////////////////////////////////////////////////
    //
    // Author : Cotta
    // Functionality : main-flash delay function, used for strobe protection
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MVOID strobeDelay(); 

    /////////////////////////////////////////////////////////////////////////
    //
    // Author : Cotta
    // Functionality : set ZSD mode strobe on / off
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MVOID set3AZSDMode(MBOOL ZSDFlag);

    /////////////////////////////////////////////////////////////////////////
    //
    // setAutoExposureLock() -
    //! \brief enable/disable AE function
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MVOID setAutoExposureLock(MBOOL bEnable);

    /////////////////////////////////////////////////////////////////////////
    //
    // getAutoExposureLock() -
    //! \brief get AE lock state
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MBOOL getAutoExposureLock();
    
    /////////////////////////////////////////////////////////////////////////
    //
    // isAutoExposureLockSupported() -
    //! \brief AE support lock or not
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MBOOL isAutoExposureLockSupported();

    /////////////////////////////////////////////////////////////////////////
    //
    // getMaxNumMeteringAreas() -
    //! \brief get AE support max number of metering area
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MINT32 getMaxNumMeteringAreas();

    /////////////////////////////////////////////////////////////////////////
    //
    // getMeteringAreas() -
    //! \brief get AE metering area information
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MVOID getMeteringAreas(MINT32 &a_i4Cnt, AREA_T **a_psAEArea);

    /////////////////////////////////////////////////////////////////////////
    //
    // setMeteringAreas() -
    //! \brief set AE metering area information
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MVOID setMeteringAreas(MINT32 a_i4Cnt, AREA_T const *a_psAEArea);

    /////////////////////////////////////////////////////////////////////////
    //
    // isStrobeOn() -
    //! \brief strobe on or not
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MBOOL isStrobeOn();

    /////////////////////////////////////////////////////////////////////////
    //
    // isAutoWhiteBalanceLockSupported () -
    //! \brief [ICS] returns true if auto-white balance locking is supported
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MBOOL isAutoWhiteBalanceLockSupported();

    /////////////////////////////////////////////////////////////////////////
    //
    // getAutoWhiteBalanceLock () -
    //! \brief [ICS] Gets the state of the auto-white balance lock: Returns true if auto-white balance is currently locked, and false otherwise
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MBOOL getAutoWhiteBalanceLock();

    /////////////////////////////////////////////////////////////////////////
    //
    // setAutoWhiteBalanceLock () -
    //! \brief [ICS] If set to true, the camera auto-white balance routine will immediately pause until the lock is set to false.
    //               If auto-white balance is already locked, setting this to true again has no effect (the driver will not recalculate white balance values).
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MVOID setAutoWhiteBalanceLock(MBOOL bToggle);

    /*******************************************************************************
    // setPreviewToCaptureImage () -
    //! \brief [ICS] If set to zero, the camera will use the preview setting to capture image.
    ********************************************************************************/
    virtual MVOID setPreviewToCaptureImage(MUINT32 a_CaptureMode); 

    virtual MVOID setBypassSensorSetting(MBOOL bBypassSensorSetting);

    virtual MVOID setZSDMode(MBOOL ZSDFlag);
    
    MVOID setIsBurtShootMode(MINT32 isBurst);
    /////////////////////////////////////////////////////////////////////////
    //   setHal3AMeteringModeStatus() -
    //! \brief set 3A metering mode to let AE understand the current mode.
    //! \param [in] a_i4MeteringModeStatus 0 : video preview, 1:video recording, 2:camera preview
    //! \return 0 if success, 1 if failed.
    //
    /////////////////////////////////////////////////////////////////////////
    virtual MRESULT setHal3AMeteringModeStatus(MINT32 a_i4MeteringModeStatus); 
	virtual MVOID setStrobeOn(MBOOL bEnable);

protected:


private:

    /////////////////////////////////////////////////////////////////////////
    //
    // create3AInstance () -
    //! \brief create 3A library instance
    //
    /////////////////////////////////////////////////////////////////////////
    MTK3A* create3AInstance();

    /////////////////////////////////////////////////////////////////////////
    //
    // getAFValue () -
    //! \brief get AF value
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 getAFValue();

    /////////////////////////////////////////////////////////////////////////
    //
    // getAFValueAll () -
    //! \brief get AF value all
    //
    /////////////////////////////////////////////////////////////////////////
    MVOID getAFValueAll(AF_STAT_T &a_rAFStat);

    /////////////////////////////////////////////////////////////////////////
    //
    // getEZoomInfo () -
    //! \brief get zoom info
    //
    /////////////////////////////////////////////////////////////////////////
    MVOID getEZoomInfo(EZOOM_WIN_T &a_eZoomInfo);

    /////////////////////////////////////////////////////////////////////////
    //
    // getFDInfo () -
    //! \brief get FD info
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 getFDInfo(FD_INFO_T &a_sFDInfo);

    /////////////////////////////////////////////////////////////////////////
    //
    // setExpParam () -
    //! \brief set exposure parameter
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setExpParam(MUINT32 a_u4ExpTime, MUINT32 a_u4SensorGain, MUINT32 a_u4RawGain);

    /////////////////////////////////////////////////////////////////////////
    //
    // setEShutterParam () -
    //! \brief set exposure parameter
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setEShutterParam(MUINT32 a_u4ExpTime, MUINT32 a_u4SensorGain);

    /////////////////////////////////////////////////////////////////////////
    //
    // setBestShotConfig () -
    //! \brief set 3A configuration for best shot
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32  setBestShotConfig();

    /////////////////////////////////////////////////////////////////////////
    //
    // writeIspRegs () -
    //! \brief write ISP registers
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 writeIspRegs(MUINT32 a_u4StartRegAddr, MUINT32 a_u4Count, MUINT32 *a_pRegData);

    /////////////////////////////////////////////////////////////////////////
    //
    // readIspRegs () -
    //! \brief read ISP registers
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 readIspRegs(MUINT32 a_u4StartRegAddr, MUINT32 a_u4Count, MUINT32 *a_pRegData);

    /////////////////////////////////////////////////////////////////////////
    //
    // holdIspRegs () -
    //! \brief hold ISP registers (S/W double buffer)
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 holdIspRegs(MBOOL a_bHold);

    /////////////////////////////////////////////////////////////////////////
    //
    // setIsp3AStatGain () -
    //! \brief set ISP 3A statistics gain
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setIsp3AStatGain();

    /////////////////////////////////////////////////////////////////////////
    //
    // setIspPreprocessingCtrl2 () -
    //! \brief set ISP preprocessing contrl 2 register
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setIspPreprocessingCtrl2(AAA_STAT_CONFIG_T &a_r3AStatConfig);

    /////////////////////////////////////////////////////////////////////////
    //
    // setIspAEWinConfig () -
    //! \brief set ISP AE window config parameter
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setIspAEWinConfig(AAA_STAT_CONFIG_T &a_r3AStatConfig);

    /////////////////////////////////////////////////////////////////////////
    //
    // setIspFDAEWinConfig () -
    //! \brief set ISP FD AE window config parameter
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setIspFDAEWinConfig(AAA_STAT_CONFIG_T &a_r3AStatConfig);

    /////////////////////////////////////////////////////////////////////////
    //
    // setIspAFWinConfig () -
    //! \brief set ISP AF window config parameter
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setIspAFWinConfig(AAA_STAT_CONFIG_T &a_r3AStatConfig);

    /////////////////////////////////////////////////////////////////////////
    //
    // setIspAFThr () -
    //! \brief set ISP AF threshold
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setIspAFThr(AAA_STAT_CONFIG_T &a_r3AStatConfig);

    /////////////////////////////////////////////////////////////////////////
    //
    // setIspAWBWinConfig () -
    //! \brief set ISP AWB window config parameter
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setIspAWBWinConfig(AAA_STAT_CONFIG_T &a_r3AStatConfig);

    /////////////////////////////////////////////////////////////////////////
    //
    // setIsp3AStatConfig () -
    //! \brief set ISP 3A statistics config parameter
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setIsp3AStatConfig(AAA_STAT_CONFIG_T &a_r3AStatConfig);

    /////////////////////////////////////////////////////////////////////////
    //
    // getIsp3AStat () -
    //! \brief get ISP 3A statistics
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 getIsp3AStat(AAA_STAT_T &a_r3AStat);

    /////////////////////////////////////////////////////////////////////////
    //
    // setIspFlare () -
    //! \brief set ISP flare
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setIspFlare(strFlareCFG &a_rFlareConfig);

    /////////////////////////////////////////////////////////////////////////
    //
    // setIspRAWGain () -
    //! \brief set ISP RAW gain
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setIspRAWGain(MUINT32 a_u4IncreaseGain, MBOOL a_bBypassOBGain);

    /////////////////////////////////////////////////////////////////////////
    //
    // setCaptureIspRAWGain () -
    //! \brief set ISP RAW gain
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setCaptureIspRAWGain(MUINT32 a_u4IncreaseGain);

    /////////////////////////////////////////////////////////////////////////
    //
    // setIspAWBGain () -
    //! \brief set the AWB gain
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setIspAWBGain(AWB_GAIN_T &a_rAWBGain, MBOOL bSyncWithVD);

    /////////////////////////////////////////////////////////////////////////
    //
    // setSensorExpTime () -
    //! \brief set sensor exposure
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setSensorExpTime(MUINT32 a_u4ExpTime);

    /////////////////////////////////////////////////////////////////////////
    //
    // setSensorGain () -
    //! \brief set sensor gain
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setSensorGain(MUINT32 a_u4SensorGain);

    /////////////////////////////////////////////////////////////////////////
    //
    // setSensorFrameRate () -
    //! \brief set sensor frame rate
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setSensorFrameRate(MUINT32 a_u4SensorFrameRate);

    /////////////////////////////////////////////////////////////////////////
    //
    // getFocusInfo () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 getFocusInfo(FOCUS_INFO_T &a_rFocusInfo);

    /////////////////////////////////////////////////////////////////////////
    //
    // setFocusPos () -
    //! \brief
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setFocusPos(MINT32 a_i4FocusPos);

    /////////////////////////////////////////////////////////////////////////
    //
    // setAEMode () -
    //! \brief set AE mode
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setAEMode(MINT32 a_i4AEMode);

    /////////////////////////////////////////////////////////////////////////
    //
    // setAEEVCompMode () -
    //! \brief set AE EV compensation mode
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setAEEVCompMode(MINT32 a_i4AEEVCompMode);

    /////////////////////////////////////////////////////////////////////////
    //
    // setAEMeteringMode () -
    //! \brief set AE metering mode
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setAEMeteringMode(MINT32 a_i4AEMeteringMode);

    /////////////////////////////////////////////////////////////////////////
    //
    // setAEISOSpeed () -
    //! \brief set AE ISO speed
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setAEISOSpeed(MINT32 a_i4AEISOSpeed);

    /////////////////////////////////////////////////////////////////////////
    //
    // setAEStrobeMode () -
    //! \brief set AE strobe mode
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setAEStrobeMode(MINT32 a_i4AEStrobeMode);

    /////////////////////////////////////////////////////////////////////////
    //
    // setAEFlashlightType () -
    //! \brief set AE flashlight type
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setAEFlashlightType(MINT32 a_iAEFlashlightType);

    /////////////////////////////////////////////////////////////////////////
    //
    // setAEFlickerMode () -
    //! \brief set AE flicker mode
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setAEFlickerMode(MINT32 a_i4AEFlickerMode);

    /////////////////////////////////////////////////////////////////////////
    //
    // setAEFrameRateMode () -
    //! \brief set AE frame-rate mode
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setAEFrameRateMode(MINT32 a_i4AEFrameRateMode);
    
    /////////////////////////////////////////////////////////////////////////
    //
    // setAEFlickerAutoMode () -
    //! \brief set AE flicker auto mode
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setAEFlickerAutoMode(MINT32 a_i4AEFlickerAutoMode);
    
     /////////////////////////////////////////////////////////////////////////
    //
    // setSensorFlickerFrameRate () -
    //! \brief set sensor flicker frame-rate
    //
    /////////////////////////////////////////////////////////////////////////   
    MINT32 setSensorFlickerFrameRate(MBOOL a_flickerEnable);

    /////////////////////////////////////////////////////////////////////////
    //
    // setAFMode () -
    //! \brief set AF mode
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setAFMode(MINT32 a_i4AFMode);

    /////////////////////////////////////////////////////////////////////////
    //
    // setAFMeteringMode () -
    //! \brief set AF metering mode
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setAFMeteringMode(MINT32 a_i4AFMeteringMode);

    /////////////////////////////////////////////////////////////////////////
    //
    // setAWBMode () -
    //! \brief set AWB mode
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 setAWBMode(MINT32 a_i4AWBMode);

    /////////////////////////////////////////////////////////////////////////
    //
    // updateCapParamsByHDR () -
    //! \brief update the capture parameters for HDR
    //
    /////////////////////////////////////////////////////////////////////////
    MINT32 updateCapParamsByHDR();

    NvramDrvBase *m_pNvramDrvObj;
    IspDrv *m_pIspDrvObj;
    MCUDrv *m_pMcuDrvObj;
    StrobeDrv *m_pStrobeDrvObj;
    SensorDrv *m_pSensorDrvObj;
    MTK3A *m_pmtk3A;


    AAA_OUTPUT_PARAM_T m_r3AOutput;
    AAA_STAT_CONFIG_T m_r3AStatConfig;
    EZOOM_WIN_T m_rEZoomInfo;
    FD_INFO_T m_rFDInfo;
    AAA_DEBUG_INFO_T m_r3ADebugInfo;
    AF_WIN_RESULT_T m_rAFWinResult;

    // 3A NVRAM data
    NVRAM_CAMERA_3A_STRUCT m_r3ANVRAMData;
    NVRAM_LENS_PARA_STRUCT m_rAFNVRAMData;

    isp_reg_t *m_pIspReg;
    AAA_STATE_T m_e3AState;
    MBOOL m_bCancelAF;
    MBOOL m_bFlareAuto;
    MUINT32 m_u4PreviewFlareOffset;
    CAMERA_DUAL_CAMERA_SENSOR_ENUM m_eSensorType;
    MUINT32 m_u4SensorID;
    MBOOL m_bLockExposureSetting;
    MBOOL m_bAEASDInfoReady;
    MBOOL m_bAFASDInfoReady;
    MBOOL m_bAWBASDInfoReady;

    MINT32 m_i4AFLampMode;
    MBOOL m_bAFLampStatus;    
    MBOOL m_bAFLampIsOn;
    MINT32 m_i4AFLampCnt;
    MINT32 m_i4AFLampOffCnt;
    
    MBOOL m_bFlashActive;

    MINT32 m_bFlickerState;

    Hal3A_HDROutputParam_T m_strHDROutputInfo;

    volatile MINT32            m_Users;
    mutable android::Mutex     m_Lock;

    MUINT32 strobeZSDMFOffset;  //cotta-- added for strobe protection in ZSD mode
    MBOOL   strobeZSDMode;      // cotta-- added for ZSD mode strobe control
};

/*******************************************************************************
*
********************************************************************************/
class aaaTimer {
public:
    inline MINT32 getUsTime()
    {
        struct timeval tv;
        gettimeofday(&tv, NULL);

        return tv.tv_sec * 1000000 + tv.tv_usec;
    }

    aaaTimer(const char* info)
        : mInfo(info), mIdx(0)
    {
        mStartTime = getUsTime();
    }

    MVOID printTime()
    {
        MINT32 endTime = getUsTime();
        XLOGD("[%s, %d time] =====> %d ms \n", mInfo, mIdx++, (endTime - mStartTime) / 1000);
    }

    ~aaaTimer()
    {
    }

protected:
    const char* mInfo;
    MINT32 mStartTime;
    MINT32 mIdx;
};

#endif

